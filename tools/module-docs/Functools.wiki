{{Documentation}}
{{Helper module
|name = Functools

|fname1 = <nowiki>Maybe.alt(&nbsp;m1, m2&nbsp;)</nowiki>
|ftype1 = <samp>generic: T</samp><br><samp>m1: Maybe<T> First Maybe</samp><br><samp>m2: Maybe<T> Second Maybe</samp><br><samp>-> Maybe<T></samp>
|fuse1 = Alternative operation - return first Just value or Nothing if all are Nothing

|fname2 = <nowiki>Maybe.ap(&nbsp;mf&nbsp;)</nowiki>
|ftype2 = <samp>generic: T</samp><br><samp>mf: Maybe<fun(x: T): U> Maybe containing a function</samp><br><samp>-> fun(mx:</samp>
|fuse2 = Apply a function inside Maybe to a value inside Maybe (applicative)

|fname3 = <nowiki>Maybe.bind(&nbsp;f&nbsp;)</nowiki>
|ftype3 = <samp>generic: T</samp><br><samp>f: fun(x: T): Maybe<U> Function that returns a Maybe</samp><br><samp>-> fun(m:</samp>
|fuse3 = Monadic bind operation for Maybe (flatMap)

|fname4 = <nowiki>Maybe.fromMaybe(&nbsp;default&nbsp;)</nowiki>
|ftype4 = <samp>generic: T</samp><br><samp>default: T Default value to use if Maybe is Nothing</samp><br><samp>-> fun(m:</samp>
|fuse4 = Get value from Maybe with default

|fname5 = <nowiki>Maybe.isJust(&nbsp;maybe&nbsp;)</nowiki>
|ftype5 = <samp>generic: T</samp><br><samp>maybe: any</samp><br><samp>-> Maybe<T></samp>
|fuse5 = Create an empty Maybe (Nothing)

|fname6 = <nowiki>Maybe.isNothing(&nbsp;maybe&nbsp;)</nowiki>
|ftype6 = <samp>generic: T</samp><br><samp>maybe: Maybe<T> Maybe to check</samp><br><samp>-> boolean</samp>
|fuse6 = Check if Maybe is Nothing

|fname7 = <nowiki>Maybe.just(&nbsp;value&nbsp;)</nowiki>
|ftype7 = <samp>value: any</samp><br><samp>-> any</samp>
|fuse7 = @class Maybe<any> @field value any{{!}}nil The contained value @field isNothing boolean Whether this Maybe is Nothing

|fname8 = <nowiki>Maybe.lift2(&nbsp;f&nbsp;)</nowiki>
|ftype8 = <samp>generic: T</samp><br><samp>f: fun(x: T): fun(y: U): V Binary function to lift</samp><br><samp>-> fun(mx:</samp>
|fuse8 = Lift a binary function to work with Maybe values

|fname9 = <nowiki>Maybe.sequence(&nbsp;maybes&nbsp;)</nowiki>
|ftype9 = <samp>generic: T</samp><br><samp>maybes: Maybe<T>[] Array of Maybe values</samp><br><samp>-> Maybe<T[]></samp>
|fuse9 = Sequence a list of Maybe values

|fname10 = <nowiki>Maybe.traverse(&nbsp;f, xs&nbsp;)</nowiki>
|ftype10 = <samp>generic: T</samp><br><samp>f: fun(x: T): Maybe<U> Function that returns Maybe</samp><br><samp>xs: T[] Array to traverse</samp><br><samp>-> Maybe<U[]></samp>
|fuse10 = Traverse an array applying a function that returns Maybe

|fname11 = <nowiki>Result.err(&nbsp;error&nbsp;)</nowiki>
|ftype11 = <samp>generic: T</samp><br><samp>error: E The error value</samp><br><samp>-> Result<T,</samp>
|fuse11 = Create a failed result

|fname12 = <nowiki>Result.ok(&nbsp;value&nbsp;)</nowiki>
|ftype12 = <samp>value: any</samp><br><samp>-> any</samp>
|fuse12 = @class Result<T, E> @field success boolean Whether operation succeeded @field value T{{!}}nil The value if successful @field error E{{!}}nil The error if failed

|fname13 = <nowiki>ops.add(&nbsp;a, b&nbsp;)</nowiki>
|ftype13 = <samp>a: any</samp><br><samp>b: any</samp><br><samp>-> any</samp>
|fuse13 = @class Operations

|fname14 = <nowiki>ops.ap(&nbsp;a, b&nbsp;)</nowiki>
|ftype14 = <samp>a: string First value</samp><br><samp>b: string Second value</samp><br><samp>-> string</samp>
|fuse14 = String concatenation

|fname15 = <nowiki>ops.div(&nbsp;a, b&nbsp;)</nowiki>
|ftype15 = <samp>a: number First number</samp><br><samp>b: number Second number</samp><br><samp>-> number</samp>
|fuse15 = Division operation

|fname16 = <nowiki>ops.eq(&nbsp;a, b&nbsp;)</nowiki>
|ftype16 = <samp>a: any First value</samp><br><samp>b: any Second value</samp><br><samp>-> boolean</samp>
|fuse16 = Equality comparison

|fname17 = <nowiki>ops.gt(&nbsp;a, b&nbsp;)</nowiki>
|ftype17 = <samp>a: any First value</samp><br><samp>b: any Second value</samp><br><samp>-> boolean</samp>
|fuse17 = Greater than comparison

|fname18 = <nowiki>ops.lt(&nbsp;a, b&nbsp;)</nowiki>
|ftype18 = <samp>a: any First value</samp><br><samp>b: any Second value</samp><br><samp>-> boolean</samp>
|fuse18 = Less than comparison

|fname19 = <nowiki>ops.mod(&nbsp;a, b&nbsp;)</nowiki>
|ftype19 = <samp>a: number First number</samp><br><samp>b: number Second number</samp><br><samp>-> number</samp>
|fuse19 = Modulo operation

|fname20 = <nowiki>ops.mul(&nbsp;a, b&nbsp;)</nowiki>
|ftype20 = <samp>a: number First number</samp><br><samp>b: number Second number</samp><br><samp>-> number</samp>
|fuse20 = Multiplication operation

|fname21 = <nowiki>ops.pow(&nbsp;a, b&nbsp;)</nowiki>
|ftype21 = <samp>a: number Base</samp><br><samp>b: number Exponent</samp><br><samp>-> number</samp>
|fuse21 = Power operation

|fname22 = <nowiki>ops.sub(&nbsp;a, b&nbsp;)</nowiki>
|ftype22 = <samp>a: number First number</samp><br><samp>b: number Second number</samp><br><samp>-> number</samp>
|fuse22 = Subtraction operation

|fname23 = <nowiki>validation.default_value(&nbsp;value, default&nbsp;)</nowiki>
|ftype23 = <samp>generic: T</samp><br><samp>value: T {{!}} nil Input value</samp><br><samp>default: T Default value</samp><br><samp>-> T</samp>
|fuse23 = Return default value if input is nil/empty

|fname24 = <nowiki>validation.validate_options(&nbsp;options, rules&nbsp;)</nowiki>
|ftype24 = <samp>options: table Options to validate</samp><br><samp>rules: table Rule set</samp><br><samp>-> string {{!}} nil</samp>
|fuse24 = Validate options against rule set

|fname25 = <nowiki>validation.validate_value(&nbsp;value, rules&nbsp;)</nowiki>
|ftype25 = <samp>value: any</samp><br><samp>rules: any</samp><br><samp>-> any</samp>
|fuse25 = @class Validation

|fname26 = <nowiki>ap(&nbsp;f&nbsp;)</nowiki>
|ftype26 = <samp>generic: A</samp><br><samp>f: fun(x: A): fun(y: B): C Function to apply</samp><br><samp>-> fun(g:</samp>
|fuse26 = Substitute combinator. S combinator. (a → b → c) → (a → b) → a → c

|fname27 = <nowiki>append(&nbsp;arr, element&nbsp;)</nowiki>
|ftype27 = <samp>generic: T</samp><br><samp>arr: T[] Array to append to</samp><br><samp>element: T Element to append</samp><br><samp>-> T[]</samp>
|fuse27 = Append element to array without mutation

|fname28 = <nowiki>apply(&nbsp;f&nbsp;)</nowiki>
|ftype28 = <samp>generic: A</samp><br><samp>f: fun(x: A): B Function to apply</samp><br><samp>-> fun(x:</samp>
|fuse28 = Apply function. A combinator. (a -> b) -> a -> b

|fname29 = <nowiki>bimap(&nbsp;left_f, right_f&nbsp;)</nowiki>
|ftype29 = <samp>generic: A</samp><br><samp>left_f: any</samp><br><samp>right_f: fun(x: B): C Function to apply to right element</samp><br><samp>-> table<1,</samp>
|fuse29 = Apply function to right element of pair

|fname30 = <nowiki>binop_on_pair(&nbsp;op&nbsp;)</nowiki>
|ftype30 = <samp>op: any</samp><br><samp>-> any</samp>
|fuse30 = No description available.

|fname31 = <nowiki>blackbird(&nbsp;f&nbsp;)</nowiki>
|ftype31 = <samp>generic: A</samp><br><samp>f: fun(c: C): D Unary function</samp><br><samp>-> fun(g:</samp>
|fuse31 = Blackbird combinator - (c → d) → (a → b → c) → a → b → d

|fname32 = <nowiki>c2(&nbsp;fn&nbsp;)</nowiki>
|ftype32 = <samp>fn: any</samp><br><samp>-> any</samp>
|fuse32 = No description available.

|fname33 = <nowiki>c3(&nbsp;fn&nbsp;)</nowiki>
|ftype33 = <samp>fn: any</samp><br><samp>-> any</samp>
|fuse33 = No description available.

|fname34 = <nowiki>c4(&nbsp;fn&nbsp;)</nowiki>
|ftype34 = <samp>fn: any</samp><br><samp>-> any</samp>
|fuse34 = No description available.

|fname35 = <nowiki>chain(&nbsp;f&nbsp;)</nowiki>
|ftype35 = <samp>generic: A</samp><br><samp>f: fun(x: A): fun(y: B): C Function to chain</samp><br><samp>-> fun(g:</samp>
|fuse35 = Chain combinator. S_ combinator. (a → b → c) → (b → a) → b → c

|fname36 = <nowiki>chain_safe(&nbsp;operations&nbsp;)</nowiki>
|ftype36 = <samp>generic: T</samp><br><samp>operations: function[] Array of functions to chain</samp><br><samp>-> function</samp>
|fuse36 = Chain safe operations

|fname37 = <nowiki>choose(&nbsp;pred, p&nbsp;)</nowiki>
|ftype37 = <samp>generic: T</samp><br><samp>pred: boolean Predicate to determine which element to choose</samp><br><samp>p: table<1, T, 2, T> Pair of elements</samp><br><samp>-> T</samp>
|fuse37 = Choose element from pair based on predicate

|fname38 = <nowiki>comp(&nbsp;f&nbsp;)</nowiki>
|ftype38 = <samp>generic: A</samp><br><samp>f: fun(x: B): C Outer function</samp><br><samp>-> fun(g:</samp>
|fuse38 = Function composition. B combinator. (b → c) → (a → b) → a → c

|fname39 = <nowiki>complement(&nbsp;predicate&nbsp;)</nowiki>
|ftype39 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Predicate to complement</samp><br><samp>-> fun(x:</samp>
|fuse39 = Complement a predicate function

|fname40 = <nowiki>compose(&nbsp;...&nbsp;)</nowiki>
|ftype40 = <samp>...: any</samp><br><samp>-> function</samp>
|fuse40 = Generic compose with varargs @vararg function Functions to compose, rightmost is applied first

|fname41 = <nowiki>compose_t(&nbsp;...&nbsp;)</nowiki>
|ftype41 = <samp>...: any</samp><br><samp>-> function</samp>
|fuse41 = Compose transducers for efficient pipeline processing @vararg function Transducers to compose

|fname42 = <nowiki>concat(&nbsp;separator, array&nbsp;)</nowiki>
|ftype42 = <samp>separator: any</samp><br><samp>array: any</samp><br><samp>-> any</samp>
|fuse42 = No description available.

|fname43 = <nowiki>cond(&nbsp;predicate, then_fn, else_fn&nbsp;)</nowiki>
|ftype43 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Condition to check</samp><br><samp>then_fn: fun(x: T): T Function to apply if true</samp><br><samp>else_fn: any</samp><br><samp>-> fun(x:</samp>
|fuse43 = Conditional function application

|fname44 = <nowiki>cond_multi(&nbsp;pairs, default&nbsp;)</nowiki>
|ftype44 = <samp>generic: T</samp><br><samp>pairs: table<function, function> Predicate-action pairs</samp><br><samp>default: U Default value</samp><br><samp>-> fun(x:</samp>
|fuse44 = Apply a sequence of predicates, returning first match or default

|fname45 = <nowiki>const(&nbsp;x&nbsp;)</nowiki>
|ftype45 = <samp>generic: T</samp><br><samp>x: T Constant value to return</samp><br><samp>-> fun(y:</samp>
|fuse45 = Constant function. K combinator. a -> b -> a

|fname46 = <nowiki>contains_in(&nbsp;list&nbsp;)</nowiki>
|ftype46 = <samp>generic: T</samp><br><samp>list: T[] List of values to check against</samp><br><samp>-> fun(x:</samp>
|fuse46 = Create a predicate that checks if value is in list

|fname47 = <nowiki>count_calls(&nbsp;f&nbsp;)</nowiki>
|ftype47 = <samp>f: function Function to wrap</samp><br><samp>-> function,</samp>
|fuse47 = Count function calls

|fname48 = <nowiki>curried_general(&nbsp;...&nbsp;)</nowiki>
|ftype48 = <samp>...: any</samp><br><samp>-> any</samp>
|fuse48 = No description available.

|fname49 = <nowiki>curry(&nbsp;fn, target_arity&nbsp;)</nowiki>
|ftype49 = <samp>fn: function The function to curry</samp><br><samp>target_arity: integer? Optional number of arguments expected (defaults to 2)</samp><br><samp>-> function</samp>
|fuse49 = Generic curry function with performance optimizations and no variable redefinition

|fname50 = <nowiki>deep_clone(&nbsp;obj&nbsp;)</nowiki>
|ftype50 = <samp>generic: T</samp><br><samp>obj: T Table to clone</samp><br><samp>-> T</samp>
|fuse50 = Deep clone a table

|fname51 = <nowiki>deep_flatten(&nbsp;nested_array&nbsp;)</nowiki>
|ftype51 = <samp>generic: T</samp><br><samp>nested_array: any[] Array that may contain deeply nested arrays</samp><br><samp>-> T[]</samp>
|fuse51 = Deep flatten nested arrays recursively

|fname52 = <nowiki>drop(&nbsp;n&nbsp;)</nowiki>
|ftype52 = <samp>generic: T</samp><br><samp>n: integer Number of elements to drop</samp><br><samp>-> fun(xs:</samp>
|fuse52 = Drop n elements from sequence using purely functional approach

|fname53 = <nowiki>each(&nbsp;f&nbsp;)</nowiki>
|ftype53 = <samp>generic: T</samp><br><samp>f: fun(x: T): any Function to apply</samp><br><samp>-> fun(xs:</samp>
|fuse53 = Apply function to each element for side effects (functional forEach)

|fname54 = <nowiki>filter(&nbsp;predicate, xs&nbsp;)</nowiki>
|ftype54 = <samp>generic: T</samp><br><samp>predicate: fun(x: T,  i?: integer): boolean Predicate function</samp><br><samp>xs: T[] Array to filter</samp><br><samp>-> T[]</samp>
|fuse54 = Filter array elements based on predicate

|fname55 = <nowiki>filter_t(&nbsp;predicate&nbsp;)</nowiki>
|ftype55 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Predicate function</samp><br><samp>-> function</samp>
|fuse55 = Filter transducer

|fname56 = <nowiki>find(&nbsp;predicate&nbsp;)</nowiki>
|ftype56 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Predicate function</samp><br><samp>-> fun(xs:</samp>
|fuse56 = Find first element matching predicate (functional search)

|fname57 = <nowiki>first(&nbsp;p&nbsp;)</nowiki>
|ftype57 = <samp>generic: A</samp><br><samp>p: table<1, A, 2, B> Pair as table</samp><br><samp>-> A</samp>
|fuse57 = Get first element of pair

|fname58 = <nowiki>fix(&nbsp;f&nbsp;)</nowiki>
|ftype58 = <samp>generic: T</samp><br><samp>f: fun(rec: fun(x: T): R): fun(x: T): R Function that takes its own recursive call</samp><br><samp>-> fun(x:</samp>
|fuse58 = Fixed-point combinator (Y combinator approximation)

|fname59 = <nowiki>flatten(&nbsp;nested_array&nbsp;)</nowiki>
|ftype59 = <samp>generic: T</samp><br><samp>nested_array: T[][] {{!}} T[] Array that may contain nested arrays</samp><br><samp>-> T[]</samp>
|fuse59 = Flatten nested arrays into a single array (one level deep)

|fname60 = <nowiki>flatten_t(&nbsp;&nbsp;)</nowiki>
|ftype60 = <samp>-> function</samp>
|fuse60 = Flatten transducer for nested arrays

|fname61 = <nowiki>flip(&nbsp;f&nbsp;)</nowiki>
|ftype61 = <samp>generic: A</samp><br><samp>f: fun(x: A): fun(y: B): C Function whose arguments to flip</samp><br><samp>-> fun(y:</samp>
|fuse61 = Flip arguments. C combinator. (a → b → c) → b → a → c

|fname62 = <nowiki>foldl(&nbsp;f, init, ...&nbsp;)</nowiki>
|ftype62 = <samp>generic: A</samp><br><samp>f: fun(acc: A): fun(x: B): A Function to fold with</samp><br><samp>init: A Initial accumulator value</samp><br><samp>...: any</samp><br><samp>-> A</samp>
|fuse62 = Fold left with varargs @vararg B Values to fold over

|fname63 = <nowiki>fst(&nbsp;a, b&nbsp;)</nowiki>
|ftype63 = <samp>generic: A</samp><br><samp>a: A First element</samp><br><samp>b: B Second element</samp><br><samp>-> A</samp>
|fuse63 = Returns the first element of a pair

|fname64 = <nowiki>group_by(&nbsp;key_fn, xs&nbsp;)</nowiki>
|ftype64 = <samp>generic: T</samp><br><samp>key_fn: fun(x: T): K Function to extract grouping key</samp><br><samp>xs: T[] Array to group</samp><br><samp>-> table<K,</samp>
|fuse64 = Group array elements by a key function

|fname65 = <nowiki>id(&nbsp;x&nbsp;)</nowiki>
|ftype65 = <samp>generic: T</samp><br><samp>x: T Value to return</samp><br><samp>-> T</samp>
|fuse65 = Identity function. I combinator. a -> a

|fname66 = <nowiki>is_array(&nbsp;x&nbsp;)</nowiki>
|ftype66 = <samp>x: any</samp><br><samp>-> any</samp>
|fuse66 = No description available.

|fname67 = <nowiki>is_array(&nbsp;item&nbsp;)</nowiki>
|ftype67 = <samp>item: any</samp><br><samp>-> any</samp>
|fuse67 = No description available.

|fname68 = <nowiki>is_empty(&nbsp;value&nbsp;)</nowiki>
|ftype68 = <samp>value: any Value to check</samp><br><samp>-> boolean</samp>
|fuse68 = Check if value is empty (nil, empty string, or empty table)

|fname69 = <nowiki>is_nil(&nbsp;x&nbsp;)</nowiki>
|ftype69 = <samp>x: any</samp><br><samp>-> any</samp>
|fuse69 = No description available.

|fname70 = <nowiki>is_type(&nbsp;type_name&nbsp;)</nowiki>
|ftype70 = <samp>type_name: string Type name to check</samp><br><samp>-> fun(value:</samp>
|fuse70 = Check if input has specific type

|fname71 = <nowiki>iterate(&nbsp;initial, step_fn&nbsp;)</nowiki>
|ftype71 = <samp>generic: T</samp><br><samp>initial: T Starting value</samp><br><samp>step_fn: fun(x: T): T Function to generate next value</samp><br><samp>-> table</samp>
|fuse71 = Create infinite sequence from initial value and step function

|fname72 = <nowiki>join(&nbsp;f&nbsp;)</nowiki>
|ftype72 = <samp>generic: A</samp><br><samp>f: fun(x: A): fun(y: A): B Function to apply to duplicated argument</samp><br><samp>-> fun(x:</samp>
|fuse72 = Duplication function. W combinator. (a → a → b) → a → b

|fname73 = <nowiki>juxt(&nbsp;...&nbsp;)</nowiki>
|ftype73 = <samp>...: any</samp><br><samp>-> function</samp>
|fuse73 = Create a function that applies multiple functions to same input @vararg function Functions to apply

|fname74 = <nowiki>lazy(&nbsp;generator&nbsp;)</nowiki>
|ftype74 = <samp>generic: T</samp><br><samp>generator: fun(): T {{!}} nil Generator function</samp><br><samp>-> table</samp>
|fuse74 = Create a lazy sequence generator

|fname75 = <nowiki>lens(&nbsp;getter, setter&nbsp;)</nowiki>
|ftype75 = <samp>generic: S</samp><br><samp>getter: fun(s: S): A Function to get value from structure</samp><br><samp>setter: fun(a: A): fun(s: S): S Function to set value in structure</samp><br><samp>-> table<string,</samp>
|fuse75 = Create a lens for functional data access and modification

|fname76 = <nowiki>lift2(&nbsp;f&nbsp;)</nowiki>
|ftype76 = <samp>generic: A</samp><br><samp>f: fun(x: B): fun(y: C): D Function to apply to results</samp><br><samp>-> fun(g:</samp>
|fuse76 = Converge function. S2 combinator. (b → c → d) → (a → b) → (a → c) → a → d

|fname77 = <nowiki>make_pair(&nbsp;a, b&nbsp;)</nowiki>
|ftype77 = <samp>generic: T</samp><br><samp>a: any</samp><br><samp>b: any</samp><br><samp>-> table<1,</samp>
|fuse77 = Create pair with same element twice

|fname78 = <nowiki>map(&nbsp;f, xs&nbsp;)</nowiki>
|ftype78 = <samp>generic: T</samp><br><samp>f: fun(x: T,  i?: integer): U Function to apply to each element</samp><br><samp>xs: T[] Array to map over</samp><br><samp>-> U[]</samp>
|fuse78 = Map function over array elements

|fname79 = <nowiki>map_t(&nbsp;f&nbsp;)</nowiki>
|ftype79 = <samp>generic: T</samp><br><samp>f: fun(x: T): U Mapping function</samp><br><samp>-> function</samp>
|fuse79 = Map transducer

|fname80 = <nowiki>maybe_call(&nbsp;f, ...&nbsp;)</nowiki>
|ftype80 = <samp>generic: T</samp><br><samp>f: function Function to call</samp><br><samp>...: any</samp><br><samp>-> Maybe<T></samp>
|fuse80 = Maybe-style safe call

|fname81 = <nowiki>memoize(&nbsp;f&nbsp;)</nowiki>
|ftype81 = <samp>generic: A</samp><br><samp>f: fun(x: A): B Function to memoize</samp><br><samp>-> fun(x:</samp>
|fuse81 = Memoize a function for single argument

|fname82 = <nowiki>memoize_multi(&nbsp;f&nbsp;)</nowiki>
|ftype82 = <samp>generic: A</samp><br><samp>f: fun(...: A): B Function to memoize</samp><br><samp>-> fun(...:</samp>
|fuse82 = Memoize a function with multiple arguments

|fname83 = <nowiki>merge(&nbsp;t1, t2&nbsp;)</nowiki>
|ftype83 = <samp>generic: T</samp><br><samp>t1: T First table</samp><br><samp>t2: any</samp><br><samp>-> T</samp>
|fuse83 = Merge two tables (shallow copy)

|fname84 = <nowiki>null_compose(&nbsp;...&nbsp;)</nowiki>
|ftype84 = <samp>...: any</samp><br><samp>-> function</samp>
|fuse84 = Compose with early termination on nil/false @vararg function Functions to compose with null checking

|fname85 = <nowiki>on(&nbsp;f&nbsp;)</nowiki>
|ftype85 = <samp>generic: A</samp><br><samp>f: fun(x: B): fun(y: B): C Function to apply to transformed values</samp><br><samp>-> fun(g:</samp>
|fuse85 = Psi combinator. P combinator. (b → b → c) → (a → b) → a → a → c

|fname86 = <nowiki>over(&nbsp;lens, f&nbsp;)</nowiki>
|ftype86 = <samp>generic: S</samp><br><samp>lens: table<string, function> Lens object</samp><br><samp>f: fun(a: A): A Function to modify value</samp><br><samp>-> fun(s:</samp>
|fuse86 = Curried lens modify operation

|fname87 = <nowiki>pack(&nbsp;...&nbsp;)</nowiki>
|ftype87 = <samp>...: any</samp><br><samp>-> table</samp>
|fuse87 = Pack arguments into a table @vararg any Arguments to pack

|fname88 = <nowiki>partial(&nbsp;f, ...&nbsp;)</nowiki>
|ftype88 = <samp>f: function Function to partially apply</samp><br><samp>...: any</samp><br><samp>-> function</samp>
|fuse88 = Create a partial application with fixed first arguments @vararg any Arguments to fix

|fname89 = <nowiki>partition(&nbsp;predicate&nbsp;)</nowiki>
|ftype89 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Predicate function</samp><br><samp>-> fun(xs:</samp>
|fuse89 = Create a function that partitions array based on predicate

|fname90 = <nowiki>pchoose(&nbsp;p&nbsp;)</nowiki>
|ftype90 = <samp>generic: T</samp><br><samp>p: table<1, T, 2, T> Pair of elements</samp><br><samp>-> fun(pred:</samp>
|fuse90 = Curried choose function

|fname91 = <nowiki>phoenix(&nbsp;f&nbsp;)</nowiki>
|ftype91 = <samp>generic: A</samp><br><samp>f: fun(a: A): fun(b: B): fun(c: C): D Three-argument function</samp><br><samp>-> fun(g:</samp>
|fuse91 = Phoenix combinator - (a → b → c → d) → (a → b) → (a → c) → a → d

|fname92 = <nowiki>pipe(&nbsp;...&nbsp;)</nowiki>
|ftype92 = <samp>generic: T</samp><br><samp>...: any</samp><br><samp>-> fun(x:</samp>
|fuse92 = Function composition in left-to-right (pipe) order

|fname93 = <nowiki>prop_lens(&nbsp;key&nbsp;)</nowiki>
|ftype93 = <samp>generic: K</samp><br><samp>key: K Key to focus on</samp><br><samp>-> table<string,</samp>
|fuse93 = Focus on a specific key in a table (lens for table access)

|fname94 = <nowiki>range(&nbsp;start, stop&nbsp;)</nowiki>
|ftype94 = <samp>start: integer Starting number</samp><br><samp>stop: integer Ending number</samp><br><samp>-> integer[]</samp>
|fuse94 = Generate a range of numbers from start to stop

|fname95 = <nowiki>rec(&nbsp;...&nbsp;)</nowiki>
|ftype95 = <samp>...: any</samp><br><samp>-> any</samp>
|fuse95 = No description available.

|fname96 = <nowiki>recurse(&nbsp;i, ...&nbsp;)</nowiki>
|ftype96 = <samp>i: any</samp><br><samp>...: any</samp><br><samp>-> any</samp>
|fuse96 = No description available.

|fname97 = <nowiki>reduce(&nbsp;f, init, xs&nbsp;)</nowiki>
|ftype97 = <samp>generic: T</samp><br><samp>f: fun(acc: U, x: T,  i?: integer): U Reduction function</samp><br><samp>init: U Initial accumulator value</samp><br><samp>xs: T[] Array to reduce</samp><br><samp>-> U</samp>
|fuse97 = Reduce array to single value (fold left)

|fname98 = <nowiki>reverse(&nbsp;xs&nbsp;)</nowiki>
|ftype98 = <samp>generic: T</samp><br><samp>xs: T[] Array to reverse</samp><br><samp>-> T[]</samp>
|fuse98 = Reverse an array using functional approach

|fname99 = <nowiki>safe_call(&nbsp;f, ...&nbsp;)</nowiki>
|ftype99 = <samp>generic: T</samp><br><samp>f: function Function to call safely</samp><br><samp>...: any</samp><br><samp>-> boolean,</samp>
|fuse99 = Safe function call with error handling

|fname100 = <nowiki>safe_compose(&nbsp;...&nbsp;)</nowiki>
|ftype100 = <samp>...: any</samp><br><samp>-> function</samp>
|fuse100 = Safe function composition that catches errors at each step @vararg function Functions to compose safely

|fname101 = <nowiki>second(&nbsp;p&nbsp;)</nowiki>
|ftype101 = <samp>generic: A</samp><br><samp>p: table<1, A, 2, B> Pair as table</samp><br><samp>-> B</samp>
|fuse101 = Get second element of pair

|fname102 = <nowiki>set(&nbsp;lens, value&nbsp;)</nowiki>
|ftype102 = <samp>generic: S</samp><br><samp>lens: table<string, function> Lens object</samp><br><samp>value: A Value to set</samp><br><samp>-> fun(s:</samp>
|fuse102 = Curried lens set operation

|fname103 = <nowiki>snd(&nbsp;a, b&nbsp;)</nowiki>
|ftype103 = <samp>generic: A</samp><br><samp>a: A First element</samp><br><samp>b: B Second element</samp><br><samp>-> B</samp>
|fuse103 = Returns the second element of a pair

|fname104 = <nowiki>swap(&nbsp;a&nbsp;)</nowiki>
|ftype104 = <samp>generic: A</samp><br><samp>a: A First element</samp><br><samp>-> fun(b:</samp>
|fuse104 = Swaps the order of two arguments

|fname105 = <nowiki>take(&nbsp;n&nbsp;)</nowiki>
|ftype105 = <samp>generic: T</samp><br><samp>n: integer Number of elements to take</samp><br><samp>-> fun(xs:</samp>
|fuse105 = Take n elements from sequence using purely functional approach

|fname106 = <nowiki>take_t(&nbsp;n&nbsp;)</nowiki>
|ftype106 = <samp>n: number Number of items to take</samp><br><samp>-> function</samp>
|fuse106 = Take transducer for limiting result count

|fname107 = <nowiki>thread_first(&nbsp;x, ...&nbsp;)</nowiki>
|ftype107 = <samp>x: any Initial value</samp><br><samp>...: any</samp><br><samp>-> any</samp>
|fuse107 = Thread-first macro (->) @vararg function Functions to thread through

|fname108 = <nowiki>thrush(&nbsp;x&nbsp;)</nowiki>
|ftype108 = <samp>generic: A</samp><br><samp>x: A Value to pass to function</samp><br><samp>-> fun(f:</samp>
|fuse108 = Thrush combinator. T combinator. a -> (a -> b) -> b

|fname109 = <nowiki>time_fn(&nbsp;f&nbsp;)</nowiki>
|ftype109 = <samp>f: function Function to time</samp><br><samp>-> function</samp>
|fuse109 = Time a function execution

|fname110 = <nowiki>to_table(&nbsp;a, b&nbsp;)</nowiki>
|ftype110 = <samp>generic: A</samp><br><samp>a: A First value</samp><br><samp>b: B Second value</samp><br><samp>-> table<1,</samp>
|fuse110 = Create table from two values

|fname111 = <nowiki>trampoline(&nbsp;f&nbsp;)</nowiki>
|ftype111 = <samp>generic: A</samp><br><samp>f: fun(...: A): R {{!}} function Function that may return another function for trampolining</samp><br><samp>-> fun(...:</samp>
|fuse111 = Add trampolining for stack safety in recursive calls with functional improvements

|fname112 = <nowiki>transducer(&nbsp;xform&nbsp;)</nowiki>
|ftype112 = <samp>xform: any</samp><br><samp>-> any</samp>
|fuse112 = @alias Reducer<A,B> fun(acc: A, input: B): A @alias Transducer<A,B,C> fun(reducer: Reducer<A,B>): Reducer<A,C>

|fname113 = <nowiki>until_fn(&nbsp;predicate, transform&nbsp;)</nowiki>
|ftype113 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Predicate to test</samp><br><samp>transform: fun(x: T): T Function to apply</samp><br><samp>-> fun(x:</samp>
|fuse113 = Functional until combinator - repeatedly apply function until predicate is true

|fname114 = <nowiki>unwrap_or(&nbsp;result, default&nbsp;)</nowiki>
|ftype114 = <samp>generic: T</samp><br><samp>result: {[1]: boolean, [2]: T {{!}} E} Result from pcall</samp><br><samp>default: T Default value if error</samp><br><samp>-> T</samp>
|fuse114 = Safely unwrap the result of a function call

|fname115 = <nowiki>unzip(&nbsp;pairs&nbsp;)</nowiki>
|ftype115 = <samp>generic: T</samp><br><samp>pairs: table<integer, table<1, T, 2, U>> Array of pairs</samp><br><samp>-> T[],</samp>
|fuse115 = Unzip an array of pairs into two arrays

|fname116 = <nowiki>view(&nbsp;lens&nbsp;)</nowiki>
|ftype116 = <samp>generic: S</samp><br><samp>lens: table<string, function> Lens object</samp><br><samp>-> fun(s:</samp>
|fuse116 = Curried lens get operation

|fname117 = <nowiki>while_fn(&nbsp;predicate, transform&nbsp;)</nowiki>
|ftype117 = <samp>generic: T</samp><br><samp>predicate: fun(x: T): boolean Predicate to test</samp><br><samp>transform: fun(x: T): T Function to apply</samp><br><samp>-> fun(x:</samp>
|fuse117 = Functional while combinator - repeatedly apply function while predicate is true

|fname118 = <nowiki>zip(&nbsp;xs, ys&nbsp;)</nowiki>
|ftype118 = <samp>xs: any</samp><br><samp>ys: any</samp><br><samp>-> any</samp>
|fuse118 = @alias Pair<A,B> {[1]: A, [2]: B} @alias ArrayLike<T> {[integer]: T}
}}