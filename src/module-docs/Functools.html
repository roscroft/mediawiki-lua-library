<!DOCTYPE html>
<html>
<head>
    <title>Functools Module Documentation</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1 { color: #333; border-bottom: 2px solid #ccc; }
        h2 { color: #666; margin-top: 30px; }
        .function { margin: 20px 0; padding: 15px; background: #f9f9f9; border-left: 4px solid #4CAF50; }
        .definition { font-family: monospace; background: #eee; padding: 10px; border-radius: 4px; }
        .description { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Functools Module</h1>
    <div class="description">Functools - Enhanced MediaWiki Functional Programming Library Provides purely functional programming utilities, combinators, and function composition tools. ## Key Features: - **Currying**: Transform multi-argument functions into single-argument chains - **Combinators**: Classic functional programming combinators (SKI, B, C, etc.) - **Function Composition**: Pipe and compose operations for function chaining - **Maybe Monad**: Safe computation handling with Maybe type - **Array Operations**: Map, filter, fold operations with functional style - **Type Safety**: Comprehensive type annotations for development tooling ## Usage Examples: ```lua local func = require('Module:Functools') -- Currying example local add = func.c2(function(x, y) return x + y end) local add5 = add(5) print(add5(3)) --> 8 -- Composition example local double = function(x) return x * 2 end local increment = function(x) return x + 1 end local doubleAndIncrement = func.compose(increment, double) print(doubleAndIncrement(5)) --> 11 -- Maybe monad example local safe_divide = function(x, y) if y == 0 then return func.Maybe.nothing else return func.Maybe.just(x / y) end end local result = func.Maybe.map(function(x) return x * 2 end)(safe_divide(10, 2)) -- result.value == 10 ``` @module Functools @author Wiki Lua Team @license MIT @version 2.0.0 @since 1.0.0 --</div>
    <h2>Functions</h2>
    <div class="function">
        <h3>map</h3>
        <div class="definition">map = function(f)</div>
        <div class="description">Functools - Enhanced MediaWiki Functional Programming Library
Provides purely functional programming utilities, combinators, and function composition tools.
## Key Features:
- **Currying**: Transform multi-argument functions into single-argument chains
- **Combinators**: Classic functional programming combinators (SKI, B, C, etc.)
- **Function Composition**: Pipe and compose operations for function chaining
- **Maybe Monad**: Safe computation handling with Maybe type
- **Array Operations**: Map, filter, fold operations with functional style
- **Type Safety**: Comprehensive type annotations for development tooling

## Usage Examples:
```lua
local func = require('Module:Functools')

-- Currying example
local add = func.c2(function(x, y) return x + y end)
local add5 = add(5)
print(add5(3)) --> 8

-- Composition example
local double = function(x) return x * 2 end
local increment = function(x) return x + 1 end
local doubleAndIncrement = func.compose(increment, double)
print(doubleAndIncrement(5)) --> 11

-- Maybe monad example
local safe_divide = function(x, y)
    if y == 0 then return func.Maybe.nothing
    else return func.Maybe.just(x / y) end
end
local result = func.Maybe.map(function(x) return x * 2 end)(safe_divide(10, 2))
-- result.value == 10
```

@module Functools
@author Wiki Lua Team
@license MIT
@version 2.0.0
@since 1.0.0
--

-- ======================
-- MODULE IMPORTS & SETUP
-- ======================

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType

-- Compatibility layer for different Lua versions
---@diagnostic disable-next-line: deprecated
local unpack = unpack or table.unpack -- Use the global unpack in Lua 5.1, table.unpack in 5.2+

---@class Functools
local func = {}

-- ======================
-- CORE COMBINATORS - Pure Functional Programming Building Blocks
-- ======================

---Identity function. I combinator. a -> a
---@generic T
---@param x T Value to return
---@return T x The original value
function func.id(x) return x end

---Constant function. K combinator. a -> b -> a
---@generic T, U
---@param x T Constant value to return
---@return fun(y: U): T Function that always returns x
function func.const(x) return function(y) return x end end

---Apply function. A combinator. (a -> b) -> a -> b
---@generic A, B
---@param f fun(x: A): B Function to apply
---@return fun(x: A): B Function that applies f to its argument
function func.apply(f) return function(x) return f(x) end end

---Thrush combinator. T combinator. a -> (a -> b) -> b
---@generic A, B
---@param x A Value to pass to function
---@return fun(f: fun(x: A): B): B Function that passes x to its argument
function func.thrush(x) return function(f) return f(x) end end

---Duplication function. W combinator. (a → a → b) → a → b
---@generic A, B
---@param f fun(x: A): fun(y: A): B Function to apply to duplicated argument
---@return fun(x: A): B Function that passes x twice to f
function func.join(f) return function(x) return func.c2(f)(x)(x) end end

---Flip arguments. C combinator. (a → b → c) → b → a → c
---@generic A, B, C
---@param f fun(x: A): fun(y: B): C Function whose arguments to flip
---@return fun(y: B): fun(x: A): C Function with flipped arguments
function func.flip(f) return function(y) return function(x) return func.c2(f)(x)(y) end end end

---Function composition. B combinator. (b → c) → (a → b) → a → c
---@generic A, B, C
---@param f fun(x: B): C Outer function
---@return fun(g: fun(x: A): B): fun(x: A): C Function that composes f with g
function func.comp(f) return function(g) return function(x) return f(g(x)) end end end

---Substitute combinator. S combinator. (a → b → c) → (a → b) → a → c
---@generic A, B, C
---@param f fun(x: A): fun(y: B): C Function to apply
---@return fun(g: fun(x: A): B): fun(x: A): C Function that applies f(x)(g(x))
function func.ap(f) return function(g) return function(x) return func.c2(f)(x)(g(x)) end end end

---Chain combinator. S_ combinator. (a → b → c) → (b → a) → b → c
---@generic A, B, C
---@param f fun(x: A): fun(y: B): C Function to chain
---@return fun(g: fun(y: B): A): fun(y: B): C Function that applies f(g(x))(x)
function func.chain(f) return function(g) return function(x) return func.c2(f)(g(x))(x) end end end

---Converge function. S2 combinator. (b → c → d) → (a → b) → (a → c) → a → d
---@generic A, B, C, D
---@param f fun(x: B): fun(y: C): D Function to apply to results
---@return fun(g: fun(x: A): B): fun(h: fun(x: A): C): fun(x: A): D Function that applies f(g(x))(h(x))
function func.lift2(f) return function(g) return function(h) return function(x) return func.c2(f)(g(x))(h(x)) end end end end

---Psi combinator. P combinator. (b → b → c) → (a → b) → a → a → c
---@generic A, B, C
---@param f fun(x: B): fun(y: B): C Function to apply to transformed values
---@return fun(g: fun(x: A): B): fun(x: A): fun(y: A): C Function that applies f(g(x))(g(y))
function func.on(f) return function(g) return function(x) return function(y) return func.c2(f)(g(x))(g(y)) end end end end

---Phoenix combinator - (a → b → c → d) → (a → b) → (a → c) → a → d
---@generic A, B, C, D
---@param f fun(a: A): fun(b: B): fun(c: C): D Three-argument function
---@return fun(g: fun(a: A): B): fun(h: fun(a: A): C): fun(a: A): D Phoenix combinator
function func.phoenix(f)
    return function(g)
        return function(h)
            return function(x)
                return func.c3(f)(x)(g(x))(h(x))
            end
        end
    end
end

---Blackbird combinator - (c → d) → (a → b → c) → a → b → d
---@generic A, B, C, D
---@param f fun(c: C): D Unary function
---@return fun(g: fun(a: A): fun(b: B): C): fun(a: A): fun(b: B): D Blackbird combinator
function func.blackbird(f)
    return function(g)
        return function(x)
            return function(y)
                return f(func.c2(g)(x)(y))
            end
        end
    end
end

---@class Combinators
---@field id function Identity function
---@field const function Constant function
---@field apply function Apply function
---@field thrush function Thrush combinator
---@field join function Duplication function
---@field flip function Flip arguments
---@field comp function Function composition
---@field ap function Substitute combinator
---@field chain function Chain combinator
---@field lift2 function Converge function
---@field on function Psi combinator
---@field phoenix function Phoenix combinator
---@field blackbird function Blackbird combinator

-- Expose combinators at top level for easy access
func.combinators = {
    id = func.id,
    const = func.const,
    apply = func.apply,
    thrush = func.thrush,
    join = func.join,
    flip = func.flip,
    comp = func.comp,
    ap = func.ap,
    chain = func.chain,
    lift2 = func.lift2,
    on = func.on,
    phoenix = func.phoenix,
    blackbird = func.blackbird
}

-- ======================
-- CURRYING UTILITIES - Transform multi-argument functions into single-argument chains
-- ======================

---Generic curry function with performance optimizations and no variable redefinition
---@param fn function The function to curry
---@param target_arity integer? Optional number of arguments expected (defaults to 2)
---@return function Curried function
function func.curry(fn, target_arity)
    -- Default to 2 arguments if not specified
    target_arity = target_arity or 2

    -- Fast path for arity 1 (just return the function)
    if target_arity == 1 then
        return fn
    end

    -- Fast path for arity 2 (most common case)
    if target_arity == 2 then
        return function(a, b)
            if b ~= nil then
                -- Both arguments provided, call directly
                return fn(a, b)
            else
                -- Return optimized single-argument closure
                return function(b_inner) return fn(a, b_inner) end
            end
        end
    end

    -- Handle arity 3 specially (common in functional code)
    if target_arity == 3 then
        return function(a, b, c)
            if c ~= nil then
                -- All three arguments provided
                return fn(a, b, c)
            elseif b ~= nil then
                -- Two arguments provided
                return function(c_inner) return fn(a, b, c_inner) end
            else
                -- One argument provided
                return function(b_inner, c_inner)
                    if c_inner ~= nil then
                        return fn(a, b_inner, c_inner)
                    else
                        return function(c_final) return fn(a, b_inner, c_final) end
                    end
                end
            end
        end
    end

    -- General case for arity > 3
    local function curried_general(...)
        local current_args_count = select('#', ...)

        if current_args_count >= target_arity then
            -- All arguments provided
            if current_args_count == target_arity then
                return fn(...)
            else
                -- Too many arguments, limit to required arity
                local current_args = { ... }
                local needed_args = {}
                for i = 1, target_arity do
                    needed_args[i] = current_args[i]
                end
                return fn(unpack(needed_args))
            end
        end

        -- Handle partial application
        local collected_args = { ... }

        -- Return function that captures current args
        return function(...)
            local additional_args_count = select('#', ...)
            local total_args_count = current_args_count + additional_args_count

            -- Fast path: if this completes the arguments
            if total_args_count == target_arity then
                if current_args_count == 1 then
                    return fn(collected_args[1], ...)
                elseif current_args_count == 2 then
                    return fn(collected_args[1], collected_args[2], ...)
                end
            end

            -- Need to combine arguments
            local combined_args = {}
            for i = 1, current_args_count do
                combined_args[i] = collected_args[i]
            end

            local additional_args = { ... }
            for i = 1, additional_args_count do
                combined_args[current_args_count + i] = additional_args[i]
            end

            -- Either call with all arguments or recurse
            if total_args_count >= target_arity then
                return fn(unpack(combined_args, 1, target_arity))
            else
                return curried_general(unpack(combined_args))
            end
        end
    end

    return curried_general
end

-- Backwards compatibility for existing c2, c3 functions
func.c2 = function(fn) return func.curry(fn, 2) end
func.c3 = function(fn) return func.curry(fn, 3) end
func.c4 = function(fn) return func.curry(fn, 4) end

---Create a partial application with fixed first arguments
---@param f function Function to partially apply
---@vararg any Arguments to fix
---@return function Partially applied function
function func.partial(f, ...)
    local fixed_args = { ... }
    return function(...)
        local all_args = func.merge(fixed_args, { ... })
        return f(unpack(all_args))
    end
end

-- ======================
-- FUNCTION COMPOSITION & TRANSFORMATION
-- ======================

---Pack arguments into a table
---@vararg any Arguments to pack
---@return table Table containing the arguments and n field with count
function func.pack(...) return { n = select("#", ...), ... } end

---Generic compose with varargs
---@vararg function Functions to compose, rightmost is applied first
---@return function Composed function
function func.compose(...)
    -- Basic validation
    local args = func.pack(...)
    for i = 1, args.n do
        if type(args[i]) ~= 'function' then
            error("compose: argument #" .. i .. " is not a function", 2)
        end
    end

    local fnchain = { ... }

    -- Create the composed function
    local function recurse(i, ...)
        if i == 1 then return fnchain[i](...) end
        return recurse(i - 1, fnchain[i](...))
    end

    return function(...)
        return recurse(#fnchain, ...)
    end
end

---Safe function composition that catches errors at each step
---@vararg function Functions to compose safely
---@return function Composed function that returns Maybe<result>
function func.safe_compose(...)
    local fns = { ... }
    return function(x)
        local current = func.Maybe.just(x)
        for i = #fns, 1, -1 do
            current = func.Maybe.bind(function(val)
                return func.maybe_call(fns[i], val)
            end)(current)
        end
        return current
    end
end

---Compose with early termination on nil/false
---@vararg function Functions to compose with null checking
---@return function Composed function that stops on nil/false
function func.null_compose(...)
    local fns = { ... }
    return function(x)
        local current = x
        for i = #fns, 1, -1 do
            if current == nil or current == false then
                return current
            end
            current = fns[i](current)
        end
        return current
    end
end

---Fold left with varargs
---@generic A, B
---@param f fun(acc: A): fun(x: B): A Function to fold with
---@param init A Initial accumulator value
---@vararg B Values to fold over
---@return A Accumulated result
function func.foldl(f, init, ...)
    local acc = init
    local n = select("#", ...)
    for i = 1, n do
        acc = f(acc)(select(i, ...))
    end
    return acc
end

---Function composition in left-to-right (pipe) order
---@generic T, U
---@param ... fun(x: any): any[] Functions to pipe, leftmost is applied first
---@return fun(x: T): U Piped function
function func.pipe(...)
    local fns = { ... }
    return function(x)
        -- Use foldl to apply each function in sequence to the result
        return func.foldl(function(acc)
            return function(fn)
                return fn(acc)
            end
        end, x, unpack(fns))
    end
end

-- ======================
-- ARRAY OPERATIONS - Core functional array manipulations
-- ======================

---Map function over array elements
---@generic T, U
---@param f fun(x: T,  i?: integer): U Function to apply to each element
---@param xs T[] Array to map over
---@return U[] Mapped array
function func.map(f, xs)
    checkType('Module:Functools.map', 1, f, 'function')
    checkType('Module:Functools.map', 2, xs, 'table')
    local result = {}
    for i, x in ipairs(xs) do
        result[i] = f(x, i)
    end
    return result
end

---Filter array elements based on predicate
---@generic T
---@param predicate fun(x: T,  i?: integer): boolean Predicate function
---@param xs T[] Array to filter
---@return T[] Filtered array
function func.filter(predicate, xs)
    checkType('Module:Functools.filter', 1, predicate, 'function')
    checkType('Module:Functools.filter', 2, xs, 'table')
    local result = {}
    for i, x in ipairs(xs) do
        if predicate(x, i) then
            table.insert(result, x)
        end
    end
    return result
end

---Reduce array to single value (fold left)
---@generic T, U
---@param f fun(acc: U, x: T,  i?: integer): U Reduction function
---@param init U Initial accumulator value
---@param xs T[] Array to reduce
---@return U Reduced value
function func.reduce(f, init, xs)
    checkType('Module:Functools.reduce', 1, f, 'function')
    checkType('Module:Functools.reduce', 3, xs, 'table')
    local acc = init
    for i, x in ipairs(xs) do
        acc = f(acc, x, i)
    end
    return acc
end

---Create table from two values
---@generic A, B
---@param a A First value
---@param b B Second value
---@return table<1, A, 2, B> Table containing both values
function func.to_table(a, b)
    return { a, b }
end

---Merge two tables (shallow copy)
---@generic T
---@param t1 T First table
---@param t2? table Second table (optional)
---@return T Merged table
function func.merge(t1, t2)
    checkType('Module:Functools.merge', 1, t1, 'table', true)
    checkType('Module:Functools.merge', 2, t2, 'table', true)
    local result = {}
    if t1 then
        for k, v in pairs(t1) do
            result[k] = v
        end
    end
    if t2 then
        for k, v in pairs(t2) do
            result[k] = v
        end
    end
    return result
end

-- ======================
-- SEQUENCE OPERATIONS - Working with sequences and collections
-- ======================

---Generate a range of numbers from start to stop
---@param start integer Starting number
---@param stop integer Ending number
---@return integer[] Array of numbers from start to stop
function func.range(start, stop)
    local result = {}
    for i = start, stop do
        result[i - start + 1] = i
    end
    return result
end

---Take n elements from sequence using purely functional approach
---@generic T
---@param n integer Number of elements to take
---@return fun(xs: T[]): T[] Function that returns first n elements of sequence
function func.take(n)
    return function(xs)
        -- Use functional approach: create range and map to elements
        local limit = math.min(n, #xs)
        if limit <= 0 then return {} end
        local indices = func.range(1, limit)
        return func.map(function(i) return xs[i] end, indices)
    end
end

---Drop n elements from sequence using purely functional approach
---@generic T
---@param n integer Number of elements to drop
---@return fun(xs: T[]): T[] Function that returns sequence without first n elements
function func.drop(n)
    return function(xs)
        -- Use functional approach: create range and map to elements
        if n >= #xs then return {} end
        local indices = func.range(n + 1, #xs)
        return func.map(function(i) return xs[i] end, indices)
    end
end

---@alias Pair<A,B> {[1]: A, [2]: B}
---@alias ArrayLike<T> {[integer]: T}

---Zip two arrays together into pairs
---@generic T, U
---@param xs ArrayLike<T> First array
---@param ys ArrayLike<U> Second array
---@return Pair<T,U>[] Array of pairs
function func.zip(xs, ys)
    local limit = math.min(#xs, #ys)
    if limit == 0 then return {} end

    -- Use range and map for pure functional approach
    local indices = func.range(1, limit)
    return func.map(function(i)
        return func.to_table(xs[i], ys[i])
    end, indices)
end

---Unzip an array of pairs into two arrays
---@generic T, U
---@param pairs table<integer, table<1, T, 2, U>> Array of pairs
---@return T[], U[] Two separate arrays
function func.unzip(pairs)
    local firsts, seconds = {}, {}
    for i, pair in ipairs(pairs) do
        firsts[i] = pair[1]
        seconds[i] = pair[2]
    end
    return firsts, seconds
end

---Create a function that partitions array based on predicate
---@generic T
---@param predicate fun(x: T): boolean Predicate function
---@return fun(xs: T[]): T[], T[] Function that returns true and false arrays
function func.partition(predicate)
    return function(xs)
        return func.filter(predicate, xs), func.filter(func.complement(predicate), xs)
    end
end

---Find first element matching predicate (functional search)
---@generic T
---@param predicate fun(x: T): boolean Predicate function
---@return fun(xs: T[]): T|nil Function that finds first matching element
function func.find(predicate)
    return function(xs)
        for _, x in ipairs(xs) do
            if predicate(x) then
                return x
            end
        end
        return nil
    end
end

---Apply function to each element for side effects (functional forEach)
---@generic T
---@param f fun(x: T): any Function to apply
---@return fun(xs: T[]): T[] Function that applies f to each element and returns original array
function func.each(f)
    return function(xs)
        for _, x in ipairs(xs) do
            f(x)
        end
        return xs -- Return original array for chaining
    end
end

---Reverse an array using functional approach
---@generic T
---@param xs T[] Array to reverse
---@return T[] Reversed array
function func.reverse(xs)
    local len = #xs
    if len <= 1 then return xs end
    local indices = func.range(len, 1) -- Create descending range
    return func.map(function(i) return xs[i] end, indices)
end

---Flatten nested arrays into a single array (one level deep)
---@generic T
---@param nested_array T[][]|T[] Array that may contain nested arrays
---@return T[] Flattened array
function func.flatten(nested_array)
    return func.foldl(function(acc)
        return function(item)
            if type(item) == "table" and type(item[1]) ~= nil then
                -- It's an array, concatenate its elements
                for i = 1, #item do
                    acc[#acc + 1] = item[i]
                end
            else
                -- It's a single element
                acc[#acc + 1] = item
            end
            return acc
        end
    end, {}, unpack(nested_array))
end

---Deep flatten nested arrays recursively
---@generic T
---@param nested_array any[] Array that may contain deeply nested arrays
---@return T[] Deeply flattened array
function func.deep_flatten(nested_array)
    local function is_array(item)
        return type(item) == "table" and (#item > 0 or next(item) == nil)
    end

    return func.foldl(function(acc)
        return function(item)
            if is_array(item) then
                -- Recursively flatten and append
                local flattened = func.deep_flatten(item)
                for i = 1, #flattened do
                    acc[#acc + 1] = flattened[i]
                end
            else
                acc[#acc + 1] = item
            end
            return acc
        end
    end, {}, unpack(nested_array))
end

-- Add after sequence operations

---Create a lazy sequence generator
---@generic T
---@param generator fun(): T|nil Generator function
---@return table Lazy sequence object
function func.lazy(generator)
    return {</div>
    </div>

</body>
</html>