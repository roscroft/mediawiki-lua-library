{{Documentation}}
{{Helper module
|name=Array
|fname1=<nowiki>all(&nbsp;arr, check&nbsp;)</nowiki>
|ftype1 = <samp>lhs:
    number{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}number[]{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}Array</samp><br><samp>rhs:
    number{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}number[]{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}Array</samp><br><samp>funName:
    string</samp><br><samp>opName: string</samp><br><samp>fun: fun(lhs:</samp><br><samp>arr: Array<`T`>
</samp><br><samp>check: number</samp><br><samp>-> boolean</samp>
|fuse1 = Checks if every value in an array satisfies a predicate or matches a value.

* Behaviour depends on the value of <code>check</code>:
** <code>number</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>table</code>
{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>boolean</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>string</code>
- Checks that all elements in <code>arr</code> are equal to this value.
** <code>fun(elem: any, i?: integer): boolean</code> - Returns '''true''' if <code>fun</code> returns '''true''' for
every element.
** <code>nil</code> - Checks that the array doesn't contain any '''false''' elements.

|fname2 = <nowiki>any(&nbsp;arr, check&nbsp;)</nowiki>
|ftype2 = <samp>arr: Array<`T`></samp><br><samp>check: number</samp><br><samp>-> boolean</samp>
|fuse2 = Checks if at least one value in an array satisfies a predicate or matches a value.

* Behaviour depends on the value of <code>fn</code>:
** <code>number</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>table</code>
{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>boolean</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>string</code>
- Checks that <code>arr</code> contains this value.
** <code>fun(elem: any, i?: integer): boolean</code> - Returns '''true''' if <code>fn</code> returns '''true''' for
at least one element.
** <code>nil</code> - Checks that the array contains at least one non '''false''' element.

|fname3 = <nowiki>clean(&nbsp;arr&nbsp;)</nowiki>
|ftype3 = <samp>arr: Array<`T`></samp><br><samp>-> </samp>
|fuse3 = Recursively removes all metatables.

|fname4 = <nowiki>clone(&nbsp;arr, deep&nbsp;)</nowiki>
|ftype4 = <samp>arr: Array<`T`></samp><br><samp>deep?: boolean</samp><br><samp>-> </samp>
|fuse4 = Make a copy of the input table. Preserves metatables.

|fname5 = <nowiki>condenseSparse(&nbsp;arr&nbsp;)</nowiki>
|ftype5 = <samp>arr: Array<`T`></samp><br><samp>-> </samp>
|fuse5 = Remove '''nil''' values from <code>arr</code> while preserving order.

|fname6 = <nowiki>contains(&nbsp;arr, val&nbsp;)</nowiki>
|ftype6 = <samp>arr: Array<T></samp><br><samp>val: any</samp><br><samp>-> boolean</samp>
|fuse6 = Check if <code>arr</code> contains <code>val</code>.

|fname7 = <nowiki>containsAll(&nbsp;arr, t&nbsp;)</nowiki>
|ftype7 = <samp>arr: Array<T></samp><br><samp>t: any[]</samp><br><samp>-> boolean</samp>
|fuse7 = Check if <code>arr</code> contains all values in the table <code>t</code>.

|fname8 = <nowiki>containsAny(&nbsp;arr, t&nbsp;)</nowiki>
|ftype8 = <samp>arr: Array<T></samp><br><samp>t: any[]</samp><br><samp>-> boolean</samp>
|fuse8 = Check if <code>arr</code> contains any of the values in the table <code>t</code>.

|fname9 = <nowiki>convolve(&nbsp;x, y&nbsp;)</nowiki>
|ftype9 = <samp>T: number</samp><br><samp>x: Array<T></samp><br><samp>y: Array<T></samp><br><samp>-> </samp>
|fuse9 = Convolute two number arrays.

|fname10 = <nowiki>count(&nbsp;arr, check&nbsp;)</nowiki>
|ftype10 = <samp>arr: Array<`T`></samp><br><samp>check: number</samp><br><samp>-> integer</samp>
|fuse10 = Behaviour depends on the value of <code>check</code>:

** <code>number</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>table</code>
{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>boolean</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>string</code>
- Counts the number of times this value occurs in <code>arr</code>.
** <code>fun(elem: any): boolean</code> - Count the number of times the function returs '''true''' when called on
the elements of <code>arr</code>.
** <code>nil</code> - Counts the number of non '''false''' elements.

|fname11 = <nowiki>diff(&nbsp;arr, order&nbsp;)</nowiki>
|ftype11 = <samp>T: number</samp><br><samp>arr: Array<`T`></samp><br><samp>order: number?</samp><br><samp>-> </samp>
|fuse11 = Differentiate the array

|fname12 = <nowiki>each(&nbsp;arr, fn&nbsp;)</nowiki>
|ftype12 = <samp>arr: Array<`T`></samp><br><samp>fn: fun(elem:</samp><br><samp>-> any</samp>
|fuse12 = Iterate over each element in the array

* Executes the provided function for every element in the array. This function is optimized based on array type for
maximum performance:
** Standard arrays: Uses <code>ipairs</code> for optimal performance (O(n))
** Proxy/sparse arrays: Uses manual indexing with cached length (O(n))
* Examples:
<syntaxhighlight lang='lua'>
    local arr = {{({{)}}{{)}}1, 2, 3, 4, 5{{)}}
    Array.each(arr, function(value, index)
    print(string.format('arr[%d] = %s', index, value))
    end)
</syntaxhighlight>
* Works with proxy arrays too:
<syntaxhighlight lang='lua'>
    local proxy = setmetatable({{({{)}}{{)}}[1] = 'a', [2] = 'b'{{)}}, proxy_mt)
    Array.each(proxy, function(value, index)
    print(value) -- Automatically detects proxy and uses appropriate iteration
    end)
</syntaxhighlight>

|fname13 = <nowiki>filter(&nbsp;arr, fn&nbsp;)</nowiki>
|ftype13 = <samp>arr: Array<`T`></samp><br><samp>fn: fun(elem:</samp><br><samp>-> </samp>
|fuse13 = Filter array elements using a predicate function

* Creates a new array containing only elements for which the predicate function returns a truthy value. This
operation is immutable - the original array is not modified. Performance is optimized with array length caching.
* Performance characteristics:
** Time complexity: O(n) where n is the array length
** Space complexity: O(k) where k is the number of matching elements
** Uses cached array length for optimal iteration
* Examples:
<syntaxhighlight lang='lua'>
    local numbers = {{({{)}}{{)}}1, 2, 3, 4, 5, 6{{)}}
    local evens = Array.filter(numbers, function(x)
    return x % 2 == 0
    end) -- {{({{)}}{{)}}2, 4, 6{{)}}
    local people = {{({{)}}{{)}}
    {{({{)}}{{)}}name = "Alice", age = 25{{)}},
    {{({{)}}{{)}}name = "Bob", age = 17{{)}},
    {{({{)}}{{)}}name = "Charlie", age = 30{{)}}
    {{)}}
    local adults = Array.filter(people, function(person)
    return person.age >= 18
    end) -- {{({{)}}{{)}}{{({{)}}{{)}}name = "Alice", age = 25{{)}}, {{({{)}}{{)}}name = "Charlie", age =
    30{{)}}{{)}}
</syntaxhighlight>
* With index parameter:
<syntaxhighlight lang='lua'>
    local firstHalf = Array.filter(numbers, function(value, index)
    return index <= #numbers / 2 end) -- {{({{)}}{{)}}1, 2, 3{{)}} </syntaxhighlight>

        |fname14 = <nowiki>find(&nbsp;arr, check, default&nbsp;)</nowiki>
        |ftype14 = <samp>arr: Array<T></samp><br><samp>check: number</samp><br><samp>default?:
            any</samp><br><samp>-> integer? i #</samp>
        |fuse14 = Find the first element matching a condition or value.

        * Behaviour depends on the value of <code>check</code>:
        ** <code>number</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>table</code>
        {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>boolean</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}
        <code>string</code> - Value to search for in <code>arr</code>.
        ** <code>fun(elem: T, i?: integer): boolean</code> - Predicate to search for (when '''true''') in
        <code>arr</code>.
        * Searches through the array to find the first element that matches. Returns both the element and its index.
        * Performance characteristics:
        ** Direct value search: O(n) with optimized value comparison
        ** Function search: O(n) with cached array length and early termination
        ** Best case: O(1) if element is found early
        ** Worst case: O(n) if element not found or is last
        * Direct value search:
        <syntaxhighlight lang='lua'>
            local numbers = {{({{)}}{{)}}10, 20, 30, 40, 50{{)}}
            local value, index = Array.find(numbers, 30)
            print(value, index) -- 30, 3
            local notFound, idx = Array.find(numbers, 99, "default")
            print(notFound, idx) -- "default", nil
        </syntaxhighlight>
        * Function-based search:
        <syntaxhighlight lang='lua'>
            local people = {{({{)}}{{)}}
            {{({{)}}{{)}}name = "Alice", age = 25{{)}},
            {{({{)}}{{)}}name = "Bob", age = 17{{)}},
            {{({{)}}{{)}}name = "Charlie", age = 30{{)}}
            {{)}}
            local adult, pos = Array.find(people, function(person)
            return person.age >= 18
            end)
            print(adult.name, pos) -- "Alice", 1
        </syntaxhighlight>
        * Complex search with index parameter:
        <syntaxhighlight lang='lua'>
            local firstInSecondHalf = Array.find(numbers, function(value, index)
            return index > #numbers / 2
            end)
            print(firstInSecondHalf) -- 40 (first element in second half)
        </syntaxhighlight>

        |fname15 = <nowiki>find_index(&nbsp;arr, check, default&nbsp;)</nowiki>
        |ftype15 = <samp>arr: Array<T></samp><br><samp>check: number</samp><br><samp>default?:
            any</samp><br><samp>-> integer? i #</samp>
        |fuse15 = Find the index of <code>check</code> in <code>arr</code>, or the index of the function satisfying
        <code>check</code>.

        * Behaviour depends on the value of <code>check</code>:
        ** <code>number</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>table</code>
        {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>boolean</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}
        <code>string</code> - Value to search for in <code>arr</code>.
        ** <code>fun(elem: T, i?: integer): boolean</code> - Predicate to search for (when '''true''') in
        <code>arr</code>.

        |fname16 = <nowiki>get(&nbsp;arr, indices&nbsp;)</nowiki>
        |ftype16 = <samp>arr: Array<`T`></samp><br><samp>indices:
            integer{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}integer[]</samp><br><samp>->
            T{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}Array<T>{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}nil</samp>
        |fuse16 = Extracts a subset of <code>arr</code>.

        |fname17 = <nowiki>insert(&nbsp;arr, val, index, unpackVal&nbsp;)</nowiki>
        |ftype17 = <samp>arr: Array<T></samp><br><samp>val: T</samp><br><samp>index?:
            integer</samp><br><samp>unpackVal?: boolean</samp><br><samp>-> </samp>
        |fuse17 = Inserts values into <code>arr</code>.

        |fname18 = <nowiki>int(&nbsp;arr, start, stop&nbsp;)</nowiki>
        |ftype18 = <samp>arr: Array<`T`></samp><br><samp>start?: integer</samp><br><samp>stop?:
            integer</samp><br><samp>-> </samp>
        |fuse18 = Integrates the array. Effectively does
        <math>\left\{{({{)}}{{)}}\sum^{{({{)}}{{)}}n{{)}}_{{({{)}}{{)}}start{{)}}{{({{)}}{{)}}arr[n]{{)}}
            \,\Bigg{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}\, n \in [start, stop]\right\{{)}}</math>.

        |fname19 = <nowiki>intersect(&nbsp;left, right&nbsp;)</nowiki>
        |ftype19 = <samp>left: Array<T></samp><br><samp>right: Array<T></samp><br><samp>-> </samp>
        |fuse19 = Returns an array with elements that are present in both arrays.

        |fname20 = <nowiki>intersects(&nbsp;left, right&nbsp;)</nowiki>
        |ftype20 = <samp>left: Array<T></samp><br><samp>right: Array<T></samp><br><samp>-> boolean</samp>
        |fuse20 = Checks if the two arrays have at least one element in common.

        |fname21 = <nowiki>last(&nbsp;arr, offset&nbsp;)</nowiki>
        |ftype21 = <samp>arr: Array<`T`></samp><br><samp>offset?: integer</samp><br><samp>-> T</samp>
        |fuse21 = Returns the last element of <code>arr</code>.

        |fname22 = <nowiki>len(&nbsp;arr&nbsp;)</nowiki>
        |ftype22 = <samp>arr: Array<any></samp><br><samp>-> integer length</samp>
        |fuse22 = Calculates the length of arrays including proxy arrays

        * This function provides optimized length calculation for different array types:
        ** Standard arrays: Uses native # operator (O(1))
        ** Proxy arrays: Uses exponential search followed by binary search (O(log n))
        ** Empty arrays: Quick detection and return (O(1))
        <syntaxhighlight lang='lua'>
            local std_array = {{({{)}}{{)}}1, 2, 3{{)}} -- Standard array
            local proxy_array = setmetatable({{({{)}}{{)}}[1] = 'a', [2] = 'b'{{)}}, proxy_mt)
            print(len(std_array)) -- 3 (O(1) operation)
            print(len(proxy_array)) -- 2 (O(log n) operation)
            print(len({{({{)}}{{)}}{{)}})) -- 0 (O(1) early detection)
        </syntaxhighlight>

        |fname23 = <nowiki>map(&nbsp;arr, fn&nbsp;)</nowiki>
        |ftype23 = <samp>arr: Array<`T`></samp><br><samp>fn: fun(elem:</samp><br><samp>-> </samp>
        |fuse23 = Transform array elements using a mapping function

        * Creates a new array by applying the transformation function to every element of the input array. This
        operation is immutable - the original array is not modified. Supports filtering during mapping by returning
        nil for unwanted elements.
        * Performance characteristics:
        ** Time complexity: O(n) where n is the array length
        ** Space complexity: O(m) where m is the number of non-nil results
        ** Uses cached array length and optimized result building
        ** Automatically filters out nil results for sparse result arrays
        * Examples:
        <syntaxhighlight lang='lua'>
            local numbers = {{({{)}}{{)}}1, 2, 3, 4, 5{{)}}
            local doubled = Array.map(numbers, function(x)
            return x * 2
            end) -- {{({{)}}{{)}}2, 4, 6, 8, 10{{)}}
            local words = {{({{)}}{{)}}"hello", "world", "test"{{)}}
            local lengths = Array.map(words, function(word)
            return #word
            end) -- {{({{)}}{{)}}5, 5, 4{{)}}
        </syntaxhighlight>
        * Map with filtering (nil values are excluded):
        <syntaxhighlight lang='lua'>
            local mixed = {{({{)}}{{)}}1, 2, 3, 4, 5{{)}}
            local evenDoubled = Array.map(mixed, function(x)
            if x % 2 == 0 then
            return x * 2
            else
            return nil -- This will be filtered out
            end
            end) -- {{({{)}}{{)}}4, 8{{)}}
        </syntaxhighlight>
        * Using index parameter:
        <syntaxhighlight lang='lua'>
            local indexed = Array.map(numbers, function(value, index)
            return string.format('%d: %s', index, value)
            end) -- {{({{)}}{{)}}"1: 1", "2: 2", "3: 3", "4: 4", "5: 5"{{)}}
        </syntaxhighlight>

        |fname24 = <nowiki>max(&nbsp;arr&nbsp;)</nowiki>
        |ftype24 = <samp>T: number # T needs to be in Eq or its Lua equivalent</samp><br><samp>arr: Array<`T`>
        </samp><br><samp>-> integer i #</samp>
        |fuse24 = Find the largest value in the array.

        |fname25 = <nowiki>max_by(&nbsp;arr, fn&nbsp;)</nowiki>
        |ftype25 = <samp>arr: Array<`T`></samp><br><samp>fn: fun(elem:</samp><br><samp>-> integer i #</samp>
        |fuse25 = Find the element for which <code>fn</code> returned the largest value.

        |fname26 = <nowiki>min(&nbsp;arr&nbsp;)</nowiki>
        |ftype26 = <samp>T: number # T needs to be in Eq or its Lua equivalent</samp><br><samp>arr: Array<`T`>
        </samp><br><samp>-> integer i #</samp>
        |fuse26 = Find the smallest value in the array.

        |fname27 = <nowiki>new(&nbsp;arr&nbsp;)</nowiki>
        |ftype27 = <samp>arr?: any[]</samp><br><samp>-> </samp>
        |fuse27 = Create a new Array.

        * Converts a regular Lua table into an Array object that supports:
        ** Method chaining with colon syntax (:map, :filter, :reduce, etc.)
        ** Mathematical operators (+, -, *, /, ^, unary -)
        ** Concatenation operators (..)
        ** Equality comparison (==)
        ** Optimized iteration for different array types
        * Performance characteristics:
        ** Construction: O(n) for shallow conversion, O(n*m) for deep nested arrays
        ** Method calls: Optimized based on array type (standard vs proxy)
        ** Memory: Minimal overhead with shared metatable
        * Basic creation and method chaining:
        <syntaxhighlight lang='lua'>
            local numbers = Array.new({{({{)}}{{)}}1, 2, 3, 4, 5{{)}})
            local result = numbers
            :filter(function(x) return x > 2 end) -- {{({{)}}{{)}}3, 4, 5{{)}}
            :map(function(x) return x * x end) -- {{({{)}}{{)}}9, 16, 25{{)}}
            :reduce(function(acc, x) return acc + x end, 0) -- 50
        </syntaxhighlight>
        * Mathematical operations:
        <syntaxhighlight lang='lua'>
            local x = Array.new({{({{)}}{{)}}1, 2, 3{{)}})
            local y = Array.new({{({{)}}{{)}}4, 5, 6{{)}})
            print(-x) -- {{({{)}}{{)}}-1, -2, -3{{)}}
            print(x + 2) -- {{({{)}}{{)}}3, 4, 5{{)}}
            print(x * y) -- {{({{)}}{{)}}4, 10, 18{{)}}
            print(x .. y) -- {{({{)}}{{)}}1, 2, 3, 4, 5, 6{{)}}
        </syntaxhighlight>
        * Alternative creation syntax:
        <syntaxhighlight lang='lua'>
            local alt = Array({{({{)}}{{)}}10, 20, 30{{)}}) -- Shorthand syntax
        </syntaxhighlight>
        * Empty array:
        <syntaxhighlight lang='lua'>
            local empty = Array.new() -- Creates empty array ready for operations
        </syntaxhighlight>

        |fname28 = <nowiki>newIncrementor(&nbsp;start, step&nbsp;)</nowiki>
        |ftype28 = <samp>start?: number</samp><br><samp>step?: number</samp><br><samp>-> </samp>
        |fuse28 = Creates an object that returns a value that is <code>step</code> higher than the previous value
        each time it gets called.

        * The stored value can be read without incrementing by reading the <code>val</code> field.
        * A new stored value can be set through the <code>val</code> field.
        * A new step size can be set through the <code>step</code> field.
        <syntaxhighlight lang='lua'>
            local inc = arr.newIncrementor(10, 5)
            print( inc() ) -- 10
            print( inc() ) -- 15
            print( inc.val ) -- 15
            inc.val = 100
            inc.step = 20
            print( inc.val ) -- 100
            print( inc() ) -- 120
        </syntaxhighlight>

        |fname29 = <nowiki>promote(&nbsp;arr, attr&nbsp;)</nowiki>
        <<<<<<< HEAD |ftype29=<samp>U: number {{!}} table {{!}} boolean {{!}} string {{!}} fun(elem: any, i?:
            integer): boolean</samp><br><samp>arr: Array<`T`></samp><br><samp>attr: `U`</samp><br><samp>-> </samp>
            =======
            |ftype29 = <samp>generic: U: number {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} table
                {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} boolean {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} string
                {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} fun(elem: any, i?: integer): boolean</samp><br><samp>arr:
                Array<`T`></samp><br><samp>attr: `U`</samp><br><samp>-> </samp>
            >>>>>>> 8173d97 (ðŸ§¹ Complete project cleanup after wiki migration)
            |fuse29 = Returns a table created by promoting a key.

            |fname30 = <nowiki>range(&nbsp;start, stop, step&nbsp;)</nowiki>
            |ftype30 = <samp>T: number</samp><br><samp>start: T</samp><br><samp>stop?: T</samp><br><samp>step?:
                T</samp><br><samp>-> </samp>
            |fuse30 = Returns a range of numbers.

            |fname31 = <nowiki>reduce(&nbsp;arr, fn, accumulator&nbsp;)</nowiki>
            |ftype31 = <samp>arr: Array<`T`></samp><br><samp>fn: fun(elem:</samp><br><samp>accumulator?:
                U</samp><br><samp>-> U</samp>
            |fuse31 = Condenses the array into a single value.

            * For each element <code>fn</code> is called with the current element, the current accumulator, and the
            current element index. The returned value of <code>fn</code> becomes the accumulator for the next
            element. If no <code>accumulator</code> value is given at the start then the first element off
            <code>arr</code> becomes the accumulator and the iteration starts from the second element.
            * Examples:
            <syntaxhighlight lang='lua'>
                local t = {{({{)}}{{)}} 1, 2, 3, 4 {{)}}
                local sum = arr.reduce( t, function(elem, acc) return acc + elem end ) -- sum == 10
            </syntaxhighlight>

            |fname32 = <nowiki>reject(&nbsp;arr, check&nbsp;)</nowiki>
            |ftype32 = <samp>arr: Array<`T`></samp><br><samp>check: number</samp><br><samp>-> </samp>
            |fuse32 = Make a copy of <code>arr</code> with certain values removed.

            * Behaviour for different values of <code>check</code>:
            ** <code>number</code> {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>boolean</code>
            {{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}} <code>string</code> - Remove values equal to this.
            ** <code>table</code> - Remove values found in this table.
            ** <code>fun(elem: any, i?: integer): boolean</code> - Remove elements for which the functions returns
            '''true'''.

            |fname33 = <nowiki>rep(&nbsp;val, n&nbsp;)</nowiki>
            |ftype33 = <samp>val: `T`</samp><br><samp>n: integer</samp><br><samp>-> </samp>
            |fuse33 = Returns an Array with <code>val</code> repeated <code>n</code> times.

            |fname34 = <nowiki>scan(&nbsp;arr, fn, accumulator&nbsp;)</nowiki>
            |ftype34 = <samp>arr: Array<`T`></samp><br><samp>fn: fun(elem:</samp><br><samp>accumulator?:
                U</samp><br><samp>-> </samp>
            |fuse34 = Condenses the array into a single value while saving every accumulator value.

            * For each element <code>fn</code> is called with the current element, the current accumulator, and the
            current element index. The returned value of <code>fn</code> becomes the accumulator for the next
            element.
            * If no <code>accumulator</code> value is given at the start then the first element off <code>arr</code>
            becomes the accumulator and the iteration starts from the second element.
            * Examples:
            <syntaxhighlight lang='lua'>
                local t = {{({{)}}{{)}} 1, 2, 3, 4 {{)}}
                local x = arr.scan( t, function(elem, acc) return acc + elem end ) -- x = {{({{)}}{{)}} 1, 3, 6, 10
                {{)}}
            </syntaxhighlight>

            |fname35 = <nowiki>set(&nbsp;arr, indices, values&nbsp;)</nowiki>
            |ftype35 = <samp>arr: Array<T></samp><br><samp>indices:
                integer{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}integer[]</samp><br><samp>values:
                U{{({{)}}{{)}}{{({{)}}{{)}}!{{)}}{{)}}U[]</samp><br><samp>-> </samp>
            |fuse35 = Update a range of index with a range of values.

            * If only one value is given but multiple indices than that value is set for all those indices. If
            <code>values</code> is a table then it must of the same length as <code>indices</code>.

            |fname36 = <nowiki>slice(&nbsp;arr, start, stop&nbsp;)</nowiki>
            |ftype36 = <samp>arr: Array<T></samp><br><samp>start: integer</samp><br><samp>stop?:
                integer</samp><br><samp>-> </samp>
            |fuse36 = Extract a subtable from <code>arr</code>.

            |fname37 = <nowiki>split(&nbsp;arr, index&nbsp;)</nowiki>
            |ftype37 = <samp>arr: Array<T></samp><br><samp>index: integer</samp><br><samp>-> </samp>
            |fuse37 = Split <code>arr</code> into two arrays.

            |fname38 = <nowiki>sum(&nbsp;arr&nbsp;)</nowiki>
            |ftype38 = <samp>T: number</samp><br><samp>arr: Array<T></samp><br><samp>-> number</samp>
            |fuse38 = Returns the sum of all elements of <code>arr</code>.

            |fname39 = <nowiki>take(&nbsp;arr, count, start&nbsp;)</nowiki>
            |ftype39 = <samp>arr: Array<T></samp><br><samp>count: integer</samp><br><samp>start?:
                integer</samp><br><samp>-> </samp>
            |fuse39 = Extract a subtable from <code>arr</code>.

            |fname40 = <nowiki>take_every(&nbsp;arr, n, start, count&nbsp;)</nowiki>
            |ftype40 = <samp>arr: Array<T></samp><br><samp>n: integer</samp><br><samp>start?:
                integer</samp><br><samp>count?: integer</samp><br><samp>-> </samp>
            |fuse40 = Extract a subtable from <code>arr</code>.

            * Examples:
            <syntaxhighlight lang='lua'>
                local t = {{({{)}}{{)}} 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 {{)}}
                local x = arr.take_every( t, 2 ) -- x = {{({{)}}{{)}} 1, 3, 5, 7, 9 {{)}}
                local x = arr.take_every( t, 2, 3 ) -- x = {{({{)}}{{)}} 3, 5, 7, 9 {{)}}
                local x = arr.take_every( t, 2, 3, 2 ) -- x = {{({{)}}{{)}} 3, 5 {{)}}
            </syntaxhighlight>

            |fname41 = <nowiki>unique(&nbsp;arr, fn&nbsp;)</nowiki>
            |ftype41 = <samp>arr: Array<`T`></samp><br><samp>fn?: fun(elem:</samp><br><samp>-> </samp>
            |fuse41 = Return a new table with all duplicates removed.

            |fname42 = <nowiki>zip(&nbsp;...&nbsp;)</nowiki>
            |ftype42 = <samp>...: Array<T></samp><br><samp>-> </samp>
            |fuse42 = Combine elements with the same index from multiple arrays.

            * Examples:
            <syntaxhighlight lang='lua'>
                local x = {{({{)}}{{)}}1, 2, 3{{)}}
                local y = {{({{)}}{{)}}4, 5, 6, 7{{)}}
                local z = arr.zip( x, y ) -- z = {{({{)}}{{)}} {{({{)}}{{)}} 1, 4 {{)}}, {{({{)}}{{)}} 2, 5 {{)}},
                {{({{)}}{{)}} 3, 6 {{)}}, {{({{)}}{{)}} 7 {{)}} {{)}}
            </syntaxhighlight>

            |example =
            <syntaxhighlight lang='lua'>
                -- Example usage of Array will be added manually
            </syntaxhighlight>
            }}