<!DOCTYPE html>
<html>
<head>
    <title>Array Module Documentation</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1 { color: #333; border-bottom: 2px solid #ccc; }
        h2 { color: #666; margin-top: 30px; }
        .function { margin: 20px 0; padding: 15px; background: #f9f9f9; border-left: 4px solid #4CAF50; }
        .definition { font-family: monospace; background: #eee; padding: 10px; border-radius: 4px; }
        .description { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Array Module</h1>
    <div class="description">==================================== MediaWiki Array Module - Enhanced ==================================== A comprehensive functional programming library for array operations in MediaWiki Lua modules. This module provides immutable array operations with performance optimizations for various array types including standard Lua arrays, proxy tables, and sparse arrays. Features: - Immutable array operations with copy-on-write semantics - Smart optimization for different array types (standard vs proxy) - Comprehensive functional programming utilities (map, filter, reduce, etc.) - Performance-optimized iteration patterns - Type-safe operations with comprehensive error checking - Integration with MediaWiki's proxy table system @module Array @version 2.1.0 @author Multiple contributors @since 2024 --</div>
    <h2>Functions</h2>
    <div class="function">
        <h3>check</h3>
        <div class="definition">check = function(item)</div>
        <div class="description">@as any[] 
        local rhsArray_len = len(rhsArray)
        for i = 1, rhsArray_len do
            res[i] = fun(lhs, rhsArray[i])
        end
    elseif type(rhs) == 'number' then
        local lhsArray = lhs @as any[] 
        local lhsArray_len = len(lhsArray)
        for i = 1, lhsArray_len do
            res[i] = fun(lhsArray[i], rhs)
        end
    else
        local lhsArray = lhs @as any[] 
        local rhsArray = rhs @as any[] 
        local lhsArray_len = len(lhsArray)
        local rhsArray_len = len(rhsArray)
        assert(lhsArray_len == rhsArray_len,
            string.format('Elementwise %s failed because arrays have different sizes (left: %d, right: %d)', opName,
                lhsArray_len, rhsArray_len))
        for i = 1, lhsArray_len do
            res[i] = fun(lhsArray[i], rhsArray[i])
        end
    end

    return setmetatable(res, getmetatable(lhs) or getmetatable(rhs))
end

function Array.__add(lhs, rhs)
    return mathTemplate(lhs, rhs, '__add', 'addition', function(x, y) return x + y end)
end

function Array.__sub(lhs, rhs)
    return mathTemplate(lhs, rhs, '__sub', 'substraction', function(x, y) return x - y end)
end

function Array.__mul(lhs, rhs)
    return mathTemplate(lhs, rhs, '__mul', 'multiplication', function(x, y) return x * y end)
end

function Array.__div(lhs, rhs)
    return mathTemplate(lhs, rhs, '__div', 'division', function(x, y) return x / y end)
end

function Array.__pow(lhs, rhs)
    return mathTemplate(lhs, rhs, '__pow', 'exponentiation', function(x, y) return x ^ y end)
end

function Array.__eq(lhs, rhs)
    if len(lhs) ~= len(rhs) then
        return false
    end
    local array_len = len(lhs)
    for i = 1, array_len do
        if lhs[i] ~= rhs[i] then
            return false
        end
    end
    return true
end

---Checks if every value in an array satisfies a predicate or matches a value.
---Behaviour depends on the value of `check`:
---* `number` | `table` | `boolean` | `string` - Checks that all elements in `arr` are equal to this value.
---* `fun(elem: any, i?: integer): boolean` - Returns '''true''' if `fun` returns '''true''' for every element.
---* `nil` - Checks that the array doesn't contain any '''false''' elements.
---@generic T
---@param arr Array<`T`>
---@param check number | table | boolean | string | fun(elem: T, i?: integer): boolean | nil
---@return boolean
function Array.all(arr, check)
    checkType('Module:Array.all', 1, arr, 'table')
    checkTypeMulti('Module:Array.all', 2, check, { 'number', 'table', 'boolean', 'string', 'function', 'nil' })
    if check == nil then check = function(item) return item end end
    if type(check) ~= 'function' then
        local val = check</div>
    </div>
    <div class="function">
        <h3>__call</h3>
        <div class="definition">__call = function()</div>
        <div class="description">@as integer[] 
    local res = {}
    local arrLength = len(arr)
    for i = 1, len(indexArray) do
        local idx = indexArray[i]
        if idx >= 1 and idx <= arrLength then
            res[i] = arr[idx]
        else
            res[i] = nil
        end
    end
    return setmetatable(res, getmetatable(arr))
end

---Integrates the array. Effectively does <math>\left\{\sum^{n}_{start}{arr[n]} \,\Bigg|\, n \in [start, stop]\right\}</math>.
---@generic T
---@param arr Array<`T`> # number
---@param start? integer # Index where to start the summation. Defaults to 1.
---@param stop? integer # Index where to stop the summation. Defaults to #arr.
---@return Array<T>
function Array.int(arr, start, stop)
    checkType('Module:Array.int', 1, arr, 'table')
    checkType('Module:Array.int', 2, start, 'number', true)
    checkType('Module:Array.int', 3, stop, 'number', true)
    local res = {}
    start = start or 1
    stop = stop or len(arr)
    res[1] = arr[start]
    for i = 1, stop - start do
        res[i + 1] = res[i] + arr[start + i]
    end
    return setmetatable(res, getmetatable(arr))
end

---Returns an array with elements that are present in both arrays.
---@generic T
---@param left Array<T>
---@param right Array<T>
---@return Array<T>
function Array.intersect(left, right)
    checkType('Module:Array.intersect', 1, left, 'table')
    checkType('Module:Array.intersect', 2, right, 'table')
    local arr2Elements = {}
    local res = {}
    local l = 0
    Array.each(right, function(item) arr2Elements[item] = true end)
    Array.each(left, function(item)
        if arr2Elements[item] then
            l = l + 1
            res[l] = item
        end
    end)
    return setmetatable(res, getmetatable(left) or getmetatable(right))
end

---Checks if the two arrays have at least one element in common.
---@generic T
---@param left Array<T>
---@param right Array<T>
---@return boolean
function Array.intersects(left, right)
    checkType('Module:Array.intersects', 1, left, 'table')
    checkType('Module:Array.intersects', 2, right, 'table')
    local small = {}
    local large
    if len(left) <= len(right) then
        Array.each(left, function(item) small[item] = true end)
        large = right
    else
        Array.each(right, function(item) small[item] = true end)
        large = left
    end
    return Array.any(large, function(item) return small[item] end)
end

---Inserts values into `arr`.
---@generic T
---@param arr Array<T>
---@param val T # If `val` is an array and `unpackVal` is '''true''' then the individual elements of `val` are inserted.
---@param index? integer # Location to start the insertion. Default is at the end of `arr`.
---@param unpackVal? boolean # Default is '''false'''.
---@return Array<T>
function Array.insert(arr, val, index, unpackVal)
    checkType('Module:Array.insert', 1, arr, 'table')
    checkTypeMulti('Module:Array.insert', 3, index, { 'number', 'boolean', 'nil' })
    checkType('Module:Array.insert', 4, unpackVal, 'boolean', true)
    if type(index) == 'boolean' then
        unpackVal, index = index, nil
    end
    local l = len(arr)
    index = index or (l + 1)
    local mt = getmetatable(arr)
    setmetatable(arr, nil)

    if unpackVal and type(val) == 'table' then
        local l2 = len(val)
        for i = 0, l - index do
            arr[l + l2 - i] = arr[l - i]
        end
        for i = 0, l2 - 1 do
            arr[index + i] = val[i + 1]
        end
    else
        table.insert(arr, index, val)
    end

    return setmetatable(arr, mt)
end

---Returns the last element of `arr`.
---@generic T
---@param arr Array<`T`>
---@param offset? integer # Offset from the end (default 0, -1 for second to last, etc.)
---@return T
function Array.last(arr, offset)
    checkType('Module:Array.last', 1, arr, 'table')
    checkType('Module:Array.last', 2, offset, 'number', true)
    local length = len(arr)
    if length == 0 then
        return nil
    end
    local index = length + (offset or 0)
    if index < 1 or index > length then
        return nil
    end
    return arr[index]
end

---Transform array elements using a mapping function
---
---Creates a new array by applying the transformation function to every element of the input array. This operation is immutable - the original array is not modified. Supports filtering during mapping by returning nil for unwanted elements.
---
---Performance characteristics:
---- Time complexity: O(n) where n is the array length
---- Space complexity: O(m) where m is the number of non-nil results
---- Uses cached array length and optimized result building
---- Automatically filters out nil results for sparse result arrays
---Examples:
---```
---local numbers = {1, 2, 3, 4, 5}
---local doubled = Array.map(numbers, function(x)
---    return x * 2
---end)  -- {2, 4, 6, 8, 10}
---
---local words = {"hello", "world", "test"}
---local lengths = Array.map(words, function(word)
---    return #word
---end)  -- {5, 5, 4}
---```
---Map with filtering (nil values are excluded):
---```
---local mixed = {1, 2, 3, 4, 5}
---local evenDoubled = Array.map(mixed, function(x)
---    if x % 2 == 0 then
---        return x * 2
---    else
---        return nil  -- This will be filtered out
---    end
---end)  -- {4, 8}
---```
---Using index parameter:
---```
---local indexed = Array.map(numbers, function(value, index)
---    return string.format('%d: %s', index, value)
---end)  -- {"1: 1", "2: 2", "3: 3", "4: 4", "5: 5"}
---```
---@generic T, U
---@param arr Array<`T`> # Array to transform
---@param fn fun(elem: T, i?: integer): `U` # Transformation function
---@return Array<U> # New array containing transformed elements
function Array.map(arr, fn)
    checkType('Module:Array.map', 1, arr, 'table')
    checkType('Module:Array.map', 2, fn, 'function')

    local l = 0
    local r = {}
    local array_len = len(arr)
    for i = 1, array_len do
        local tmp = fn(arr[i], i)
        if tmp ~= nil then
            l = l + 1
            r[l] = tmp
        end
    end
    return setmetatable(r, getmetatable(arr))
end

---Find the element for which `fn` returned the largest value.
---@generic T, U # U needs to be in the Eq class or its Lua equivalent
---@param arr Array<`T`>
---@param fn fun(elem: T): U # The returned value needs to be comparable using the `<` operator.
---@return T elem # The element with the largest `fn` value.
---@return U value # The largest `fn` value.
---@return integer i # The index of this element.
function Array.max_by(arr, fn)
    checkType('Module:Array.max_by', 1, arr, 'table')
    checkType('Module:Array.max_by', 2, fn, 'function')
    -- Commenting out check until we can review the correctness of max_by returning a value for an empty array
    --local length = len(arr)
    --if length == 0 then
    --	error("Module:Array.max_by: array cannot be empty")
    --end
    local result = Array.reduce(arr, function(new, old, i)
        local y = fn(new)
        return y > old[2] and { new, y, i } or old
    end, { nil, -math.huge, 0 })
    return result[1], result[2], result[3]
end

---Find the largest value in the array.
---@generic T: number # T needs to be in Eq or its Lua equivalent
---@param arr Array<`T`> # The values need to be comparable using the `<` operator.
---@return T elem
---@return integer i # The index of the largest value.
function Array.max(arr)
    checkType('Module:Array.max', 1, arr, 'table')
    if len(arr) == 0 then
        error("Module:Array.max: array cannot be empty")
    end
    local val, _, i = Array.max_by(arr, function(x) return x end)
    return val, i
end

---Find the smallest value in the array.
---@generic T: number # T needs to be in Eq or its Lua equivalent
---@param arr Array<`T`> # The values need to be comparable using the `<` operator.
---@return T elem
---@return integer i # The index of the largest value.
function Array.min(arr)
    checkType('Module:Array.min', 1, arr, 'table')
    if len(arr) == 0 then
        error("Module:Array.min: array cannot be empty")
    end
    local val, _, i = Array.max_by(arr, function(x) return -x end)
    return val, i
end

---Create a new Array.
---Converts a regular Lua table into an Array object that supports:
---- Method chaining with colon syntax (:map, :filter, :reduce, etc.)
---- Mathematical operators (+, -, *, /, ^, unary -)
---- Concatenation operators (..)
---- Equality comparison (==)
---- Optimized iteration for different array types
---
---Performance characteristics:
---- Construction: O(n) for shallow conversion, O(n*m) for deep nested arrays
---- Method calls: Optimized based on array type (standard vs proxy)
---- Memory: Minimal overhead with shared metatable
---Basic creation and method chaining:
---```
---local numbers = Array.new({1, 2, 3, 4, 5})
---local result = numbers
---    :filter(function(x) return x > 2 end)  -- {3, 4, 5}
---    :map(function(x) return x * x end)     -- {9, 16, 25}
---    :reduce(function(acc, x) return acc + x end, 0)  -- 50
---```
---Mathematical operations:
---```
---local x = Array.new({1, 2, 3})
---local y = Array.new({4, 5, 6})
---print(-x)      -- {-1, -2, -3}
---print(x + 2)   -- {3, 4, 5}
---print(x * y)   -- {4, 10, 18}
---print(x .. y)  -- {1, 2, 3, 4, 5, 6}
---```
---Alternative creation syntax:
---```
---local alt = Array({10, 20, 30}) -- Shorthand syntax
---```
---Empty array:
---```
---local empty = Array.new() -- Creates empty array ready for operations
---```
---@generic T
---@param arr? any[] # Optional input table (creates empty array if nil)
---@return Array<T> # RS Wiki Array
function Array.new(arr)
    local obj = arr or {}
    for _, v in pairs(obj) do
        if type(v) == 'table' then
            Array.new(v)
        end
    end

    if getmetatable(obj) == nil then
        setmetatable(obj, Array)
    end

    return obj
end

---@class Array.Incrementor
---@field val number # Current value that can be read/written
---@field step number # Step size that can be read/written

---Creates an object that returns a value that is `step` higher than the previous value each time it gets called.
---The stored value can be read without incrementing by reading the `val` field.
---A new stored value can be set through the `val` field.
---A new step size can be set through the `step` field.
---```
---local inc = arr.newIncrementor(10, 5)
---print( inc() ) -- 10
---print( inc() ) -- 15
---print( inc.val ) -- 15
---inc.val = 100
---inc.step = 20
---print( inc.val ) -- 100
---print( inc() ) -- 120
---```
---@param start? number # Default is 1.
---@param step? number # Default is 1.
---@return Array.Incrementor
function Array.newIncrementor(start, step)
    checkType('Module:Array.newIncrementor', 1, start, 'number', true)
    checkType('Module:Array.newIncrementor', 2, step, 'number', true)
    step = step or 1
    local n = (start or 1) - step
    local obj = {}
    return setmetatable(obj, {</div>
    </div>

</body>
</html>